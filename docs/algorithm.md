
# Описание алгоритма  
**Плагиат** - копирование чужого кода в точности или с незначительной его обработкой  
##  Типы совпадений исходного кода  
1. Оба фрагмента кода идентичны (за исключением комментариев и пробелов).  
2. Оба фрагмента кода идентичны за исключением имён переменных, строковых литералов, типов данных.  
3. Новый фрагмент кода был получен из предыдущего путём добавления или удаления операторов языка.  
4. Оба фрагмента кода выполняют одинаковые действия, но реализованы по-разному.    
	

Первый и второй тип - незначительные изменения.  Третий  тип  распознать  сложнее,  обычно  к этому  типу  можно  отнести  участки  кода,  которые  специально  пытались замаскировать,  внося  дополнительный  «шум». Четвертый тип плагиата свойственен промышленному программированию и может не обрабатываться антиплагиатом тестирующей системы.  

## Этапы преобразования и анализа исходного кода
1. Нормализация
2. Лексический анализ
3. Анализ характеристик программы
4. Алгоритм Вагнера-Фишера
5. Шинглинг
	

### 1. Нормализация

Данный этап предназначен для более удобной работы с исходным текстом программы на следующих этапах.  
Все символы табуляции и перевода строк заменяются на пробелы, все последовательности пробелов - единственным пробелом (кроме языков, где пробелы играют синтаксическую роль e.g. Python).  
Все символы переводятся в нижний регистр.  
Все комментарии удаляются.  

### 2. Лексический анализ (токенизация)  

Наиболее зависимый от конкертного языка этап.  
Исходный текст программы преобразуется в набор *лексем*(*токенов*) - минимальных единица языка, имеющих самостоятельный смысл. 
Виды лексем:
* имена (идентификаторы);
* ключевые слова;
* знаки операций;
* разделители;
* литералы (константы).

## 3. Анализ характеристик программы
На данном этапе рассматриваются определенные характеристики программы, которые с трудом изменяются при модификации.
### 3.1 Частота появления операторов
#### Как это работает :see_no_evil:  
Вычисляется отношение количества использования конкретного оператора к количеству появлений всех операторов.
#### Почему это работает :thinking:  
Частота появления операторов не зависит от расположения блоков кода (порядка объявления функций, переменных, etc.). При незначительном изменении кода данная характеристика изменяется несущественно.  
Тем не менее, не всегда высокий процент совпадения по этой характеристике однозначно свидетельствует о наличии плагиата.

### 3.2 Взаимная корреляция двух программ
#### Как это работает :see_no_evil:  
Находится взаимная корреляция последовательностей операторов исходных кодов.
Первый оператор одной последовательности сравниваем с первым оператором другой последовательности, второй – со вторым, третий – с третьим, и так до тех пор, пока не будет исчерпана хотя бы одна из последовательностей. При каждом совпадении счетчик увеличивается.
Далее сдвигаем более короткую последовательность на один элемент и сравниваем ее первый оператор с вторым оператором, второй – с третьим, и так далее.
Процедура продолжается, пока не будет исчерпана бо&#769;льшая последовательность.
#### Почему это работает :thinking:  
Данный метод может с хорошей точностью выделять отдельные фрагменты, одинаковые с точностью до изменений *1)* и *2)*, в обеих программах, хотя и имеет зависимость от расположения блоков кода.

## 4. Алгоритм Вагнера-Фишера  

#### Как это работает :see_no_evil:    
*Алгоритм Вагнера – Фишера* позволяет вычислить кратчайшее *расстояние Левенштейна*, которое отражает сходство между двумя строками. Похожесть исходной и целевой строки измеряется как количество замен, вставки и удаления, необходимых для преобразования одной строки в другую. Расстояние Левенштейна увеличивается в зависимости от количества преобразований, необходимых для превращения одной строки в другую.
*Алгоритм Вагнера – Фишера* - классический алгоритм работы над строками, его описание и реализацию можно прочитать [здесь](https://ru.wikipedia.org/wiki/Расстояние_Левенштейна#Алгоритм_Вагнера_—_Фишера).
В нашей задаче алгоритм Вагнера-Фишера может быть использован для сравнения двух исходных, в которых роль букв играют лексемы.
Полученное в результате значение расстояния Левенштейна (LD) может быть использовано для нахождения схожести двух исходных кодов по формуле  
*{ 1 - LD / max[ code_1.size( ), code_2.size( ) ] } \* 100* 
#### Почему это работает :thinking:  
Алгоритм Вагнера-Фишера, хотя и увеличивает возвращаемое значение при внесении "шума" (тип совпадений 3), находит такого рода заимствования с большой точностью (LD увеличивается на N при добавлении/удалении N операторов).
Тем не менее, большой сложностью для данного алгоритма является поиск заимствований при изменении порядка объявлений функций большого размера.

## 5. Шинглинг
#### Как это работает :see_no_evil:   
*Шингл* - это фрагмент текста длиной в несколько слов, с которым работает программа проверки уникальности. В нашей задаче шинглом будем называть подпоследовательность из *K* лексем (токенов), *K ≈ 20*.
При этом все идентификаторы и константные значения заменяются на некоторый одинаковый элемент.
Последовательность лексем исходного кода разбивается на *N - K + 1* шинглов, где *N* - количество токенов в последовательности. Примечательно, что шинглы одной программы начинаются с каждой, кроме последних *K - 1* лексем, потому пересекаются. Это необходимо учитывать при нахождении процента плагиата.
Затем каждый из шинглов отображается в свою контрольную сумму (например, по алгоритму шифрования SHA-1), после чего находится пересечение с контрольными суммами другого исходного кода или с сохраненными в базе данных контрольными суммами уже проверенных решений.
#### Почему это работает :thinking:  
Выбор значения K не случаен: при меньших К возможны ложные срабатывания алгоритма (объявление цикла for в среднем составляет 15 лексем, простейшей функции - 10), при больших алгоритм ищет совпадения с меньшей точностью.
На работу алгоритма не влияет порядок объявления функций в силу независимости значения контрольных сумм от позиции шинглов. Единственные способы "обмануть" алгоритм - внесение дополнительного "шума", изменение места объявления переменных, замена циклов for на while. Тем не менее, в действительности полностью скрыть заимствования таким образом достаточно сложно в силу малого значения K.
Данный алгоритм достаточно точно выявляет плагиат. Возможны ложные срабатывания на очень маленьких программах. 


